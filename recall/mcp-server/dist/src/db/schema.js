/**
 * Database Schema for Recall
 *
 * SQLite schema for storing architectural decisions.
 * Generated by Plugin Factory v1.0
 */
import Database from 'better-sqlite3';
import { homedir } from 'os';
import { join } from 'path';
import { mkdirSync, existsSync } from 'fs';
const DB_DIR = process.env.DECISION_DB_PATH
    ? process.env.DECISION_DB_PATH.replace(/\/[^/]+$/, '')
    : join(homedir(), '.recall');
const DB_PATH = process.env.DECISION_DB_PATH || join(DB_DIR, 'decisions.db');
// Ensure directory exists
if (!existsSync(DB_DIR)) {
    mkdirSync(DB_DIR, { recursive: true });
}
export const db = new Database(DB_PATH);
// Enable WAL mode for better concurrency
db.pragma('journal_mode = WAL');
// Create tables
db.exec(`
  -- Projects table
  CREATE TABLE IF NOT EXISTS projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
  );

  -- Decisions table
  CREATE TABLE IF NOT EXISTS decisions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    files TEXT NOT NULL,
    reasoning TEXT NOT NULL,
    commit_hash TEXT,
    commit_url TEXT,
    tags TEXT NOT NULL DEFAULT '[]',
    context TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (project_id) REFERENCES projects(id)
  );

  -- Full-text search index (includes files for filename search)
  CREATE VIRTUAL TABLE IF NOT EXISTS decisions_fts USING fts5(
    reasoning,
    tags,
    files,
    content=decisions,
    content_rowid=id
  );

  -- Triggers to keep FTS in sync
  CREATE TRIGGER IF NOT EXISTS decisions_ai AFTER INSERT ON decisions BEGIN
    INSERT INTO decisions_fts(rowid, reasoning, tags, files)
    VALUES (new.id, new.reasoning, new.tags, new.files);
  END;

  CREATE TRIGGER IF NOT EXISTS decisions_ad AFTER DELETE ON decisions BEGIN
    INSERT INTO decisions_fts(decisions_fts, rowid, reasoning, tags, files)
    VALUES ('delete', old.id, old.reasoning, old.tags, old.files);
  END;

  CREATE TRIGGER IF NOT EXISTS decisions_au AFTER UPDATE ON decisions BEGIN
    INSERT INTO decisions_fts(decisions_fts, rowid, reasoning, tags, files)
    VALUES ('delete', old.id, old.reasoning, old.tags, old.files);
    INSERT INTO decisions_fts(rowid, reasoning, tags, files)
    VALUES (new.id, new.reasoning, new.tags, new.files);
  END;

  -- Indexes
  CREATE INDEX IF NOT EXISTS idx_decisions_project ON decisions(project_id);
  CREATE INDEX IF NOT EXISTS idx_decisions_created ON decisions(created_at);
  CREATE INDEX IF NOT EXISTS idx_decisions_commit ON decisions(commit_hash);
`);
// Migration: Check if FTS table needs to include 'files' column
// This handles upgrades from older versions that didn't index files
try {
    const ftsInfo = db.prepare("PRAGMA table_info(decisions_fts)").all();
    const hasFiles = ftsInfo.some(col => col.name === 'files');
    if (!hasFiles) {
        // Rebuild FTS table with files column
        db.exec(`
      DROP TABLE IF EXISTS decisions_fts;
      DROP TRIGGER IF EXISTS decisions_ai;
      DROP TRIGGER IF EXISTS decisions_ad;
      DROP TRIGGER IF EXISTS decisions_au;

      CREATE VIRTUAL TABLE decisions_fts USING fts5(
        reasoning,
        tags,
        files,
        content=decisions,
        content_rowid=id
      );

      CREATE TRIGGER decisions_ai AFTER INSERT ON decisions BEGIN
        INSERT INTO decisions_fts(rowid, reasoning, tags, files)
        VALUES (new.id, new.reasoning, new.tags, new.files);
      END;

      CREATE TRIGGER decisions_ad AFTER DELETE ON decisions BEGIN
        INSERT INTO decisions_fts(decisions_fts, rowid, reasoning, tags, files)
        VALUES ('delete', old.id, old.reasoning, old.tags, old.files);
      END;

      CREATE TRIGGER decisions_au AFTER UPDATE ON decisions BEGIN
        INSERT INTO decisions_fts(decisions_fts, rowid, reasoning, tags, files)
        VALUES ('delete', old.id, old.reasoning, old.tags, old.files);
        INSERT INTO decisions_fts(rowid, reasoning, tags, files)
        VALUES (new.id, new.reasoning, new.tags, new.files);
      END;

      -- Rebuild FTS index from existing data
      INSERT INTO decisions_fts(rowid, reasoning, tags, files)
      SELECT id, reasoning, tags, files FROM decisions;
    `);
    }
}
catch (e) {
    // FTS table doesn't exist yet or other issue - will be created by main schema
}
export { DB_PATH };
//# sourceMappingURL=schema.js.map