/**
 * Search Utilities
 *
 * Helper functions for decision search.
 * Generated by Plugin Factory v1.0
 */

/**
 * Common synonyms for search terms
 */
const SYNONYMS: Record<string, string[]> = {
  'state': ['state-management', 'store', 'redux', 'zustand', 'jotai', 'recoil', 'context'],
  'auth': ['authentication', 'authorization', 'login', 'oauth', 'jwt', 'session'],
  'api': ['rest', 'graphql', 'trpc', 'endpoint', 'fetch', 'axios'],
  'styling': ['css', 'styles', 'tailwind', 'styled-components', 'sass', 'scss'],
  'testing': ['test', 'tests', 'jest', 'vitest', 'cypress', 'playwright'],
  'database': ['db', 'sql', 'postgres', 'mysql', 'mongodb', 'prisma', 'orm'],
  'build': ['bundler', 'webpack', 'vite', 'esbuild', 'rollup', 'parcel'],
  'deploy': ['deployment', 'ci', 'cd', 'docker', 'kubernetes', 'vercel', 'netlify'],
};

/**
 * Expand search query with synonyms
 */
export function expandQuery(query: string): string[] {
  const terms = query.toLowerCase().split(/\s+/);
  const expanded = new Set<string>(terms);

  for (const term of terms) {
    // Check if term is a key
    if (SYNONYMS[term]) {
      for (const synonym of SYNONYMS[term]) {
        expanded.add(synonym);
      }
    }

    // Check if term is a value
    for (const [key, values] of Object.entries(SYNONYMS)) {
      if (values.includes(term)) {
        expanded.add(key);
        for (const synonym of values) {
          expanded.add(synonym);
        }
      }
    }
  }

  return Array.from(expanded);
}

/**
 * Parse a natural language question into search terms
 */
export function parseQuestion(question: string): string[] {
  // Remove question words and common words
  const stopWords = [
    'why', 'what', 'how', 'when', 'where', 'who',
    'do', 'did', 'does', 'is', 'are', 'was', 'were', 'will', 'would',
    'we', 'you', 'they', 'i', 'the', 'a', 'an',
    'use', 'using', 'used', 'choose', 'chose', 'chosen',
    'instead', 'of', 'for', 'to', 'from', 'with', 'about',
  ];

  const words = question
    .toLowerCase()
    .replace(/[?.,!'"]/g, '')
    .split(/\s+/)
    .filter(word => !stopWords.includes(word) && word.length > 1);

  return words;
}

/**
 * Score relevance of a decision to a query
 */
export function scoreRelevance(
  decision: { reasoning: string; tags: string[]; files: string[] },
  queryTerms: string[]
): number {
  let score = 0;
  const reasoning = decision.reasoning.toLowerCase();
  const tags = decision.tags.map(t => t.toLowerCase());
  const files = decision.files.map(f => f.toLowerCase());

  for (const term of queryTerms) {
    // Exact match in reasoning
    if (reasoning.includes(term)) {
      score += 10;
    }

    // Match in tags (higher weight)
    if (tags.some(t => t.includes(term) || term.includes(t))) {
      score += 20;
    }

    // Match in files
    if (files.some(f => f.includes(term))) {
      score += 5;
    }
  }

  return score;
}

/**
 * Extract keywords from reasoning for auto-tagging
 */
export function extractKeywords(text: string): string[] {
  const keywords: string[] = [];
  const lowerText = text.toLowerCase();

  // Technology keywords
  const techPatterns = [
    /\b(react|vue|angular|svelte|next\.?js|nuxt)\b/gi,
    /\b(redux|zustand|jotai|recoil|mobx)\b/gi,
    /\b(typescript|javascript|python|rust|go)\b/gi,
    /\b(prisma|drizzle|mongoose|sequelize)\b/gi,
    /\b(postgres|mysql|mongodb|sqlite|redis)\b/gi,
    /\b(jest|vitest|cypress|playwright|mocha)\b/gi,
    /\b(tailwind|styled-components|emotion|sass|scss)\b/gi,
    /\b(webpack|vite|esbuild|rollup|parcel)\b/gi,
    /\b(docker|kubernetes|vercel|netlify|aws)\b/gi,
    /\b(graphql|trpc|rest|grpc)\b/gi,
    /\b(oauth|jwt|auth0|clerk|supabase)\b/gi,
  ];

  for (const pattern of techPatterns) {
    const matches = text.match(pattern);
    if (matches) {
      keywords.push(...matches.map(m => m.toLowerCase()));
    }
  }

  // Concept keywords
  const concepts = [
    'state-management', 'authentication', 'authorization',
    'caching', 'performance', 'security', 'testing',
    'deployment', 'architecture', 'refactor', 'migration',
  ];

  for (const concept of concepts) {
    if (lowerText.includes(concept.replace('-', ' ')) || lowerText.includes(concept)) {
      keywords.push(concept);
    }
  }

  return [...new Set(keywords)];
}
