/**
 * Database Queries for Recall
 *
 * All database operations for storing and retrieving decisions.
 * Generated by Plugin Factory v1.0
 */

import { db, Decision, DecisionWithProject, Project } from './schema.js';

// Prepared statements for better performance
const stmts = {
  // Projects
  getProject: db.prepare('SELECT * FROM projects WHERE path = ?'),
  getProjectById: db.prepare('SELECT * FROM projects WHERE id = ?'),
  insertProject: db.prepare('INSERT INTO projects (path, name) VALUES (?, ?)'),
  listProjects: db.prepare('SELECT * FROM projects ORDER BY created_at DESC'),

  // Decisions
  getDecision: db.prepare(`
    SELECT d.*, p.path as project_path, p.name as project_name
    FROM decisions d
    JOIN projects p ON d.project_id = p.id
    WHERE d.id = ?
  `),

  insertDecision: db.prepare(`
    INSERT INTO decisions (project_id, files, reasoning, commit_hash, commit_url, tags, context)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `),

  updateDecision: db.prepare(`
    UPDATE decisions
    SET reasoning = ?, tags = ?, context = ?, updated_at = datetime('now')
    WHERE id = ?
  `),

  linkCommit: db.prepare(`
    UPDATE decisions
    SET commit_hash = ?, commit_url = ?, updated_at = datetime('now')
    WHERE id = ?
  `),

  getRecentDecisions: db.prepare(`
    SELECT d.*, p.path as project_path, p.name as project_name
    FROM decisions d
    JOIN projects p ON d.project_id = p.id
    ORDER BY d.created_at DESC
    LIMIT ?
  `),

  getProjectDecisions: db.prepare(`
    SELECT d.*, p.path as project_path, p.name as project_name
    FROM decisions d
    JOIN projects p ON d.project_id = p.id
    WHERE p.path = ?
    ORDER BY d.created_at DESC
    LIMIT ?
  `),

  getFileDecisions: db.prepare(`
    SELECT d.*, p.path as project_path, p.name as project_name
    FROM decisions d
    JOIN projects p ON d.project_id = p.id
    WHERE d.files LIKE ?
    ORDER BY d.created_at DESC
  `),

  // Full-text search
  searchDecisions: db.prepare(`
    SELECT d.*, p.path as project_path, p.name as project_name,
           bm25(decisions_fts) as rank
    FROM decisions d
    JOIN projects p ON d.project_id = p.id
    JOIN decisions_fts fts ON fts.rowid = d.id
    WHERE decisions_fts MATCH ?
    ORDER BY rank
    LIMIT ?
  `),

  searchProjectDecisions: db.prepare(`
    SELECT d.*, p.path as project_path, p.name as project_name,
           bm25(decisions_fts) as rank
    FROM decisions d
    JOIN projects p ON d.project_id = p.id
    JOIN decisions_fts fts ON fts.rowid = d.id
    WHERE decisions_fts MATCH ? AND p.path = ?
    ORDER BY rank
    LIMIT ?
  `),

  countProjectDecisions: db.prepare(`
    SELECT COUNT(*) as count FROM decisions d
    JOIN projects p ON d.project_id = p.id
    WHERE p.path = ?
  `),
};

/**
 * Get or create a project
 */
export function getOrCreateProject(projectPath: string): Project {
  let project = stmts.getProject.get(projectPath) as Project | undefined;

  if (!project) {
    // Extract name from path
    const name = projectPath.split('/').pop() || projectPath;
    const result = stmts.insertProject.run(projectPath, name);
    project = stmts.getProjectById.get(result.lastInsertRowid) as Project;
  }

  return project;
}

/**
 * Add a new decision
 */
export function addDecision(params: {
  project: string;
  files: string[];
  reasoning: string;
  commit?: string | null;
  commitUrl?: string | null;
  tags?: string[];
  context?: string | null;
}): DecisionWithProject {
  const project = getOrCreateProject(params.project);

  const result = stmts.insertDecision.run(
    project.id,
    JSON.stringify(params.files),
    params.reasoning,
    params.commit || null,
    params.commitUrl || null,
    JSON.stringify(params.tags || []),
    params.context || null
  );

  return getDecision(Number(result.lastInsertRowid))!;
}

/**
 * Get a decision by ID
 */
export function getDecision(id: number): DecisionWithProject | null {
  const row = stmts.getDecision.get(id) as (DecisionWithProject & { files: string; tags: string }) | undefined;
  if (!row) return null;

  return {
    ...row,
    files: JSON.parse(row.files),
    tags: JSON.parse(row.tags),
  };
}

/**
 * Link a commit to a decision
 */
export function linkCommit(decisionId: number, commitHash: string, commitUrl?: string | null): boolean {
  const result = stmts.linkCommit.run(commitHash, commitUrl || null, decisionId);
  return result.changes > 0;
}

/**
 * Get recent decisions
 */
export function getRecentDecisions(limit = 20): DecisionWithProject[] {
  const rows = stmts.getRecentDecisions.all(limit) as (DecisionWithProject & { files: string; tags: string })[];

  return rows.map(row => ({
    ...row,
    files: JSON.parse(row.files),
    tags: JSON.parse(row.tags),
  }));
}

/**
 * Get decisions for a project
 */
export function getProjectDecisions(projectPath: string, limit = 100): DecisionWithProject[] {
  const rows = stmts.getProjectDecisions.all(projectPath, limit) as (DecisionWithProject & { files: string; tags: string })[];

  return rows.map(row => ({
    ...row,
    files: JSON.parse(row.files),
    tags: JSON.parse(row.tags),
  }));
}

/**
 * Get decisions related to a file
 */
export function getFileDecisions(filePath: string): DecisionWithProject[] {
  const rows = stmts.getFileDecisions.all(`%${filePath}%`) as (DecisionWithProject & { files: string; tags: string })[];

  return rows.map(row => ({
    ...row,
    files: JSON.parse(row.files),
    tags: JSON.parse(row.tags),
  }));
}

/**
 * Search decisions using full-text search
 */
export function searchDecisions(query: string, options?: {
  project?: string;
  limit?: number;
}): DecisionWithProject[] {
  const limit = options?.limit || 20;

  // Escape special FTS5 characters and prepare query
  const ftsQuery = query
    .replace(/[*:^]/g, ' ')
    .split(/\s+/)
    .filter(term => term.length > 0)
    .map(term => `"${term}"`)
    .join(' OR ');

  if (!ftsQuery) return [];

  const rows = options?.project
    ? stmts.searchProjectDecisions.all(ftsQuery, options.project, limit)
    : stmts.searchDecisions.all(ftsQuery, limit);

  return (rows as (DecisionWithProject & { files: string; tags: string })[]).map(row => ({
    ...row,
    files: JSON.parse(row.files),
    tags: JSON.parse(row.tags),
  }));
}

/**
 * List all projects
 */
export function listProjects(): Project[] {
  return stmts.listProjects.all() as Project[];
}

/**
 * Count decisions for a project
 */
export function countProjectDecisions(projectPath: string): number {
  const result = stmts.countProjectDecisions.get(projectPath) as { count: number };
  return result.count;
}

/**
 * Export decisions in various formats
 */
export function exportDecisions(options?: {
  project?: string;
  format?: 'json' | 'markdown' | 'adr';
}): string {
  const decisions = options?.project
    ? getProjectDecisions(options.project, 1000)
    : getRecentDecisions(1000);

  const format = options?.format || 'json';

  switch (format) {
    case 'json':
      return JSON.stringify(decisions, null, 2);

    case 'markdown':
      return decisions.map(d => `
## Decision #${d.id}
**Date:** ${d.created_at}
**Project:** ${d.project_name}
**Files:** ${d.files.join(', ')}
${d.commit_hash ? `**Commit:** ${d.commit_hash}` : ''}
${d.tags.length > 0 ? `**Tags:** ${d.tags.map(t => `#${t}`).join(' ')}` : ''}

${d.reasoning}

---
`).join('\n');

    case 'adr':
      return decisions.map((d, i) => `
# ADR ${String(i + 1).padStart(4, '0')}: Decision #${d.id}

## Status
Accepted

## Context
Decision recorded on ${d.created_at} for project ${d.project_name}.
Files affected: ${d.files.join(', ')}

## Decision
${d.reasoning}

## Consequences
Tags: ${d.tags.map(t => `#${t}`).join(' ')}
${d.commit_hash ? `\nCommit: ${d.commit_hash}` : ''}
${d.commit_url ? `\nView: ${d.commit_url}` : ''}
`).join('\n---\n');

    default:
      return JSON.stringify(decisions, null, 2);
  }
}
